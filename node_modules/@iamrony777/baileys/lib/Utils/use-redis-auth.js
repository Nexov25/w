"use strict";
/**
    Using Redis to store login data
    Modified from @kreivc (https://www.kreivc.com/)
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRedisAuthState = void 0;
const WAProto_1 = require("../../WAProto");
const auth_utils_1 = require("./auth-utils");
const generics_1 = require("./generics");
const useRedisAuthState = (redis, authKey = 'auth', logger) => __awaiter(void 0, void 0, void 0, function* () {
    const writeData = (id, data) => __awaiter(void 0, void 0, void 0, function* () {
        logger === null || logger === void 0 ? void 0 : logger.debug({ id, data }, 'writing data');
        yield redis.hSet(authKey, id, JSON.stringify(data, generics_1.BufferJSON.replacer));
    });
    const readData = (id) => __awaiter(void 0, void 0, void 0, function* () {
        const data = yield redis.hGet(authKey, id);
        logger === null || logger === void 0 ? void 0 : logger.debug({ id, data }, 'reading data');
        return data ? JSON.parse(data, generics_1.BufferJSON.reviver) : null;
    });
    const creds = (yield readData('creds')) || (0, auth_utils_1.initAuthCreds)();
    return {
        state: {
            creds,
            keys: {
                get: (type, ids) => __awaiter(void 0, void 0, void 0, function* () {
                    logger === null || logger === void 0 ? void 0 : logger.debug({ ids, type }, 'getting data');
                    const data = {};
                    yield Promise.all(ids.map((id) => __awaiter(void 0, void 0, void 0, function* () {
                        let value = yield readData(`${type}-${id}`);
                        if (type === 'app-state-sync-key' && value) {
                            value = WAProto_1.proto.Message.AppStateSyncKeyData.fromObject(value);
                        }
                        data[id] = value;
                    })));
                    return data;
                }),
                set: (data) => __awaiter(void 0, void 0, void 0, function* () {
                    logger === null || logger === void 0 ? void 0 : logger.debug({ data }, 'setting data');
                    const tasks = [];
                    for (const category in data) {
                        for (const id in data[category]) {
                            const value = data[category][id];
                            const key = `${category}-${id}`;
                            tasks.push(value
                                ? writeData(key, value)
                                : redis.hDel(authKey, key));
                        }
                    }
                    yield Promise.all(tasks);
                }),
            },
        },
        saveCreds: () => __awaiter(void 0, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.debug({ creds }, 'saving creds');
            yield writeData('creds', creds);
        }),
        removeCreds: () => __awaiter(void 0, void 0, void 0, function* () {
            logger === null || logger === void 0 ? void 0 : logger.debug('deleting creds');
            yield redis.del(authKey);
        }),
    };
});
exports.useRedisAuthState = useRedisAuthState;
//# sourceMappingURL=use-redis-auth.js.map