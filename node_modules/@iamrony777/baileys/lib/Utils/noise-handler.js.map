{"version":3,"file":"noise-handler.js","sourceRoot":"/","sources":["Utils/noise-handler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Boom } from '@hapi/boom'\nimport { Logger } from 'pino'\nimport { proto } from '../../WAProto'\nimport { NOISE_MODE, WA_CERT_DETAILS } from '../Defaults'\nimport { KeyPair } from '../Types'\nimport { BinaryNode, decodeBinaryNode } from '../WABinary'\nimport { aesDecryptGCM, aesEncryptGCM, Curve, hkdf, sha256 } from './crypto'\n\nconst generateIV = (counter: number) => {\n\tconst iv = new ArrayBuffer(12)\n\tnew DataView(iv).setUint32(8, counter)\n\n\treturn new Uint8Array(iv)\n}\n\nexport const makeNoiseHandler = ({\n\tkeyPair: { private: privateKey, public: publicKey },\n\tNOISE_HEADER,\n\tmobile,\n\tlogger,\n}: {\n\tkeyPair: KeyPair\n\tNOISE_HEADER: Uint8Array\n\tmobile: boolean\n\tlogger: Logger\n}) => {\n\tlogger = logger.child({ class: 'ns' })\n\n\tconst authenticate = (data: Uint8Array) => {\n\t\tif(!isFinished) {\n\t\t\thash = sha256(Buffer.concat([hash, data]))\n\t\t}\n\t}\n\n\tconst encrypt = (plaintext: Uint8Array) => {\n\t\tconst result = aesEncryptGCM(plaintext, encKey, generateIV(writeCounter), hash)\n\n\t\twriteCounter += 1\n\n\t\tauthenticate(result)\n\t\treturn result\n\t}\n\n\tconst decrypt = (ciphertext: Uint8Array) => {\n\t\t// before the handshake is finished, we use the same counter\n\t\t// after handshake, the counters are different\n\t\tconst iv = generateIV(isFinished ? readCounter : writeCounter)\n\t\tconst result = aesDecryptGCM(ciphertext, decKey, iv, hash)\n\n\t\tif(isFinished) {\n\t\t\treadCounter += 1\n\t\t} else {\n\t\t\twriteCounter += 1\n\t\t}\n\n\t\tauthenticate(ciphertext)\n\t\treturn result\n\t}\n\n\tconst localHKDF = (data: Uint8Array) => {\n\t\tconst key = hkdf(Buffer.from(data), 64, { salt, info: '' })\n\t\treturn [key.slice(0, 32), key.slice(32)]\n\t}\n\n\tconst mixIntoKey = (data: Uint8Array) => {\n\t\tconst [write, read] = localHKDF(data)\n\t\tsalt = write\n\t\tencKey = read\n\t\tdecKey = read\n\t\treadCounter = 0\n\t\twriteCounter = 0\n\t}\n\n\tconst finishInit = () => {\n\t\tconst [write, read] = localHKDF(new Uint8Array(0))\n\t\tencKey = write\n\t\tdecKey = read\n\t\thash = Buffer.from([])\n\t\treadCounter = 0\n\t\twriteCounter = 0\n\t\tisFinished = true\n\t}\n\n\tconst data = Buffer.from(NOISE_MODE)\n\tlet hash = Buffer.from(data.byteLength === 32 ? data : sha256(data))\n\tlet salt = hash\n\tlet encKey = hash\n\tlet decKey = hash\n\tlet readCounter = 0\n\tlet writeCounter = 0\n\tlet isFinished = false\n\tlet sentIntro = false\n\n\tlet inBytes = Buffer.alloc(0)\n\n\tauthenticate(NOISE_HEADER)\n\tauthenticate(publicKey)\n\n\treturn {\n\t\tencrypt,\n\t\tdecrypt,\n\t\tauthenticate,\n\t\tmixIntoKey,\n\t\tfinishInit,\n\t\tprocessHandshake: ({ serverHello }: proto.HandshakeMessage, noiseKey: KeyPair) => {\n\t\t\tauthenticate(serverHello!.ephemeral!)\n\t\t\tmixIntoKey(Curve.sharedKey(privateKey, serverHello!.ephemeral!))\n\n\t\t\tconst decStaticContent = decrypt(serverHello!.static!)\n\t\t\tmixIntoKey(Curve.sharedKey(privateKey, decStaticContent))\n\n\t\t\tconst certDecoded = decrypt(serverHello!.payload!)\n\n\t\t\tif(mobile) {\n\t\t\t\tproto.CertChain.NoiseCertificate.decode(certDecoded)\n\t\t\t} else {\n\t\t\t\tconst { intermediate: certIntermediate } = proto.CertChain.decode(certDecoded)\n\n\t\t\t\tconst { issuerSerial } = proto.CertChain.NoiseCertificate.Details.decode(certIntermediate!.details!)\n\n\t\t\t\tif(issuerSerial !== WA_CERT_DETAILS.SERIAL) {\n\t\t\t\t\tthrow new Boom('certification match failed', { statusCode: 400 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst keyEnc = encrypt(noiseKey.public)\n\t\t\tmixIntoKey(Curve.sharedKey(noiseKey.private, serverHello!.ephemeral!))\n\n\t\t\treturn keyEnc\n\t\t},\n\t\tencodeFrame: (data: Buffer | Uint8Array) => {\n\t\t\tif(isFinished) {\n\t\t\t\tdata = encrypt(data)\n\t\t\t}\n\n\t\t\tconst introSize = sentIntro ? 0 : NOISE_HEADER.length\n\t\t\tconst frame = Buffer.alloc(introSize + 3 + data.byteLength)\n\n\t\t\tif(!sentIntro) {\n\t\t\t\tframe.set(NOISE_HEADER)\n\t\t\t\tsentIntro = true\n\t\t\t}\n\n\t\t\tframe.writeUInt8(data.byteLength >> 16, introSize)\n\t\t\tframe.writeUInt16BE(65535 & data.byteLength, introSize + 1)\n\t\t\tframe.set(data, introSize + 3)\n\n\t\t\treturn frame\n\t\t},\n\t\tdecodeFrame: (newData: Buffer | Uint8Array, onFrame: (buff: Uint8Array | BinaryNode) => void) => {\n\t\t\t// the binary protocol uses its own framing mechanism\n\t\t\t// on top of the WS frames\n\t\t\t// so we get this data and separate out the frames\n\t\t\tconst getBytesSize = () => {\n\t\t\t\tif(inBytes.length >= 3) {\n\t\t\t\t\treturn (inBytes.readUInt8() << 16) | inBytes.readUInt16BE(1)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinBytes = Buffer.concat([ inBytes, newData ])\n\n\t\t\tlogger.trace(`recv ${newData.length} bytes, total recv ${inBytes.length} bytes`)\n\n\t\t\tlet size = getBytesSize()\n\t\t\twhile(size && inBytes.length >= size + 3) {\n\t\t\t\tlet frame: Uint8Array | BinaryNode = inBytes.slice(3, size + 3)\n\t\t\t\tinBytes = inBytes.slice(size + 3)\n\n\t\t\t\tif(isFinished) {\n\t\t\t\t\tconst result = decrypt(frame)\n\t\t\t\t\tframe = decodeBinaryNode(result)\n\t\t\t\t}\n\n\t\t\t\tlogger.trace({ msg: (frame as any)?.attrs?.id }, 'recv frame')\n\n\t\t\t\tonFrame(frame)\n\t\t\t\tsize = getBytesSize()\n\t\t\t}\n\t\t}\n\t}\n}"]}