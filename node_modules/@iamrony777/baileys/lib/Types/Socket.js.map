{"version":3,"file":"Socket.js","sourceRoot":"/","sources":["Types/Socket.ts"],"names":[],"mappings":"","sourcesContent":["\nimport { AxiosRequestConfig } from 'axios'\nimport type { Agent } from 'https'\nimport type { Logger } from 'pino'\nimport type { URL } from 'url'\nimport { proto } from '../../WAProto'\nimport { AuthenticationState, SignalAuthState, TransactionCapabilityOptions } from './Auth'\nimport { MediaConnInfo } from './Message'\nimport { SignalRepository } from './Signal'\n\nexport type WAVersion = [number, number, number]\nexport type WABrowserDescription = [string, string, string]\n\nexport type CacheStore = {\n    /** get a cached key and change the stats */\n    get<T>(key: string): T | undefined\n    /** set a key in the cache */\n    set<T>(key: string, value: T): void\n    /** delete a key from the cache */\n    del(key: string): void\n    /** flush all data */\n    flushAll(): void\n}\n\nexport type SocketConfig = {\n    /** the WS url to connect to WA */\n    waWebSocketUrl: string | URL\n    /** Fails the connection if the socket times out in this interval */\n    connectTimeoutMs: number\n    /** Default timeout for queries, undefined for no timeout */\n    defaultQueryTimeoutMs: number | undefined\n    /** ping-pong interval for WS connection */\n    keepAliveIntervalMs: number\n\t/** should baileys use the mobile api instead of the multi device api */\n\tmobile?: boolean\n    /** proxy agent */\n    agent?: Agent\n    /** pino logger */\n    logger: Logger\n    /** version to connect with */\n    version: WAVersion\n    /** override browser config */\n    browser: WABrowserDescription\n    /** agent used for fetch requests -- uploading/downloading media */\n    fetchAgent?: Agent\n    /** should the QR be printed in the terminal */\n    printQRInTerminal: boolean\n    /** should events be emitted for actions done by this socket connection */\n    emitOwnEvents: boolean\n    /** custom upload hosts to upload media to */\n    customUploadHosts: MediaConnInfo['hosts']\n    /** time to wait between sending new retry requests */\n    retryRequestDelayMs: number\n    /** time to wait for the generation of the next QR in ms */\n    qrTimeout?: number\n    /** provide an auth state object to maintain the auth state */\n    auth: AuthenticationState\n    /** manage history processing with this control; by default will sync up everything */\n    shouldSyncHistoryMessage: (msg: proto.Message.IHistorySyncNotification) => boolean\n    /** transaction capability options for SignalKeyStore */\n    transactionOpts: TransactionCapabilityOptions\n    /** marks the client as online whenever the socket successfully connects */\n    markOnlineOnConnect: boolean\n\n    /** provide a cache to store media, so does not have to be re-uploaded */\n    mediaCache?: CacheStore\n    /**\n     * map to store the retry counts for failed messages;\n     * used to determine whether to retry a message or not */\n    msgRetryCounterCache?: CacheStore\n    /** provide a cache to store a user's device list */\n    userDevicesCache?: CacheStore\n    /** cache to store call offers */\n    callOfferCache?: CacheStore\n    /** width for link preview images */\n    linkPreviewImageThumbnailWidth: number\n    /** Should Baileys ask the phone for full history, will be received async */\n    syncFullHistory: boolean\n    /** Should baileys fire init queries automatically, default true */\n    fireInitQueries: boolean\n    /**\n     * generate a high quality link preview,\n     * entails uploading the jpegThumbnail to WA\n     * */\n    generateHighQualityLinkPreview: boolean\n\n    /**\n     * Returns if a jid should be ignored,\n     * no event for that jid will be triggered.\n     * Messages from that jid will also not be decrypted\n     * */\n    shouldIgnoreJid: (jid: string) => boolean | undefined\n\n    /**\n     * Optionally patch the message before sending out\n     * */\n    patchMessageBeforeSending: (\n        msg: proto.IMessage,\n        recipientJids: string[],\n    ) => Promise<proto.IMessage> | proto.IMessage\n\n    /** verify app state MACs */\n    appStateMacVerification: {\n        patch: boolean\n        snapshot: boolean\n    }\n\n    /** options for axios */\n    options: AxiosRequestConfig<{}>\n    /**\n     * fetch a message from your store\n     * implement this so that messages failed to send\n     * (solves the \"this message can take a while\" issue) can be retried\n     * */\n    getMessage: (key: proto.IMessageKey) => Promise<proto.IMessage | undefined>\n\n    makeSignalRepository: (auth: SignalAuthState) => SignalRepository\n\n    /** Socket passthrough */\n    socket?: any\n}\n"]}