{"version":3,"file":"Chat.js","sourceRoot":"/","sources":["Types/Chat.ts"],"names":[],"mappings":";;;AAiBa,QAAA,kBAAkB,GAAG,CAAC,gBAAgB,EAAE,sBAAsB,EAAE,cAAc,EAAE,aAAa,EAAE,SAAS,CAAU,CAAA","sourcesContent":["import type { proto } from '../../WAProto'\nimport type { AccountSettings } from './Auth'\nimport type { BufferedEventData } from './Events'\nimport type { ChatLabelAssociationActionBody } from './LabelAssociation'\nimport type { MessageLabelAssociationActionBody } from './LabelAssociation'\nimport type { MinimalMessage } from './Message'\n\n/** privacy settings in WhatsApp Web */\nexport type WAPrivacyValue = 'all' | 'contacts' | 'contact_blacklist' | 'none'\n\nexport type WAPrivacyOnlineValue = 'all' | 'match_last_seen'\n\nexport type WAReadReceiptsValue = 'all' | 'none'\n\n/** set of statuses visible to other people; see updatePresence() in WhatsAppWeb.Send */\nexport type WAPresence = 'unavailable' | 'available' | 'composing' | 'recording' | 'paused'\n\nexport const ALL_WA_PATCH_NAMES = ['critical_block', 'critical_unblock_low', 'regular_high', 'regular_low', 'regular'] as const\n\nexport type WAPatchName = typeof ALL_WA_PATCH_NAMES[number]\n\nexport interface PresenceData {\n    lastKnownPresence: WAPresence\n    lastSeen?: number\n}\n\nexport type ChatMutation = {\n    syncAction: proto.ISyncActionData\n    index: string[]\n}\n\nexport type WAPatchCreate = {\n    syncAction: proto.ISyncActionValue\n    index: string[]\n    type: WAPatchName\n    apiVersion: number\n    operation: proto.SyncdMutation.SyncdOperation\n}\n\nexport type Chat = proto.IConversation & {\n    /** unix timestamp of when the last message was received in the chat */\n    lastMessageRecvTimestamp?: number\n}\n\nexport type ChatUpdate = Partial<Chat & {\n    /**\n     * if specified in the update,\n     * the EV buffer will check if the condition gets fulfilled before applying the update\n     * Right now, used to determine when to release an app state sync event\n     *\n     * @returns true, if the update should be applied;\n     * false if it can be discarded;\n     * undefined if the condition is not yet fulfilled\n     * */\n    conditional: (bufferedData: BufferedEventData) => boolean | undefined\n}>\n\n/**\n * the last messages in a chat, sorted reverse-chronologically. That is, the latest message should be first in the chat\n * for MD modifications, the last message in the array (i.e. the earlist message) must be the last message recv in the chat\n * */\nexport type LastMessageList = MinimalMessage[] | proto.SyncActionValue.ISyncActionMessageRange\n\nexport type ChatModification =\n    {\n        archive: boolean\n        lastMessages: LastMessageList\n    }\n    | { pushNameSetting: string }\n    | { pin: boolean }\n    | {\n        /** mute for duration, or provide timestamp of mute to remove*/\n        mute: number | null\n    }\n    | {\n        clear: 'all' | { messages: { id: string, fromMe?: boolean, timestamp: number }[] }\n    }\n    | {\n        star: {\n            messages: { id: string, fromMe?: boolean }[]\n            star: boolean\n        }\n    }\n    | {\n        markRead: boolean\n        lastMessages: LastMessageList\n    }\n    | { delete: true, lastMessages: LastMessageList }\n    // Label assosiation\n    | { addChatLabel: ChatLabelAssociationActionBody }\n    | { removeChatLabel: ChatLabelAssociationActionBody }\n    | { addMessageLabel: MessageLabelAssociationActionBody }\n    | { removeMessageLabel: MessageLabelAssociationActionBody }\n\nexport type InitialReceivedChatsState = {\n    [jid: string]: {\n        /** the last message received from the other party */\n        lastMsgRecvTimestamp?: number\n        /** the absolute last message in the chat */\n        lastMsgTimestamp: number\n    }\n}\n\nexport type InitialAppStateSyncOptions = {\n    accountSettings: AccountSettings\n}"]}