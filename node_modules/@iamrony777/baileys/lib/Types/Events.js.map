{"version":3,"file":"Events.js","sourceRoot":"/","sources":["Types/Events.ts"],"names":[],"mappings":"","sourcesContent":["import type { Boom } from '@hapi/boom'\nimport { proto } from '../../WAProto'\nimport { AuthenticationCreds } from './Auth'\nimport { WACallEvent } from './Call'\nimport { Chat, ChatUpdate, PresenceData } from './Chat'\nimport { Contact } from './Contact'\nimport { GroupMetadata, ParticipantAction } from './GroupMetadata'\nimport { Label } from './Label'\nimport { LabelAssociation } from './LabelAssociation'\nimport { MessageUpsertType, MessageUserReceiptUpdate, WAMessage, WAMessageKey, WAMessageUpdate } from './Message'\nimport { ConnectionState } from './State'\n\nexport type BaileysEventMap = {\n    /** connection state has been updated -- WS closed, opened, connecting etc. */\n\t'connection.update': Partial<ConnectionState>\n    /** credentials updated -- some metadata, keys or something */\n    'creds.update': Partial<AuthenticationCreds>\n    /** set chats (history sync), everything is reverse chronologically sorted */\n    'messaging-history.set': {\n        chats: Chat[]\n        contacts: Contact[]\n        messages: WAMessage[]\n        isLatest: boolean\n    }\n    /** upsert chats */\n    'chats.upsert': Chat[]\n    /** update the given chats */\n    'chats.update': ChatUpdate[]\n    'chats.phoneNumberShare': {lid: string, jid: string}\n    /** delete chats with given ID */\n    'chats.delete': string[]\n    /** presence of contact in a chat updated */\n    'presence.update': { id: string, presences: { [participant: string]: PresenceData } }\n\n    'contacts.upsert': Contact[]\n    'contacts.update': Partial<Contact>[]\n\n    'messages.delete': { keys: WAMessageKey[] } | { jid: string, all: true }\n    'messages.update': WAMessageUpdate[]\n    'messages.media-update': { key: WAMessageKey, media?: { ciphertext: Uint8Array, iv: Uint8Array }, error?: Boom }[]\n    /**\n     * add/update the given messages. If they were received while the connection was online,\n     * the update will have type: \"notify\"\n     *  */\n    'messages.upsert': { messages: WAMessage[], type: MessageUpsertType }\n    /** message was reacted to. If reaction was removed -- then \"reaction.text\" will be falsey */\n    'messages.reaction': { key: WAMessageKey, reaction: proto.IReaction }[]\n\n    'message-receipt.update': MessageUserReceiptUpdate[]\n\n    'groups.upsert': GroupMetadata[]\n    'groups.update': Partial<GroupMetadata>[]\n    /** apply an action to participants in a group */\n    'group-participants.update': { id: string, participants: string[], action: ParticipantAction }\n\n    'blocklist.set': { blocklist: string[] }\n    'blocklist.update': { blocklist: string[], type: 'add' | 'remove' }\n\n    /** Receive an update on a call, including when the call was received, rejected, accepted */\n    'call': WACallEvent[]\n    'labels.edit': Label\n    'labels.association': { association: LabelAssociation, type: 'add' | 'remove' }\n}\n\nexport type BufferedEventData = {\n    historySets: {\n        chats: { [jid: string]: Chat }\n        contacts: { [jid: string]: Contact }\n        messages: { [uqId: string]: WAMessage }\n        empty: boolean\n        isLatest: boolean\n    }\n    chatUpserts: { [jid: string]: Chat }\n    chatUpdates: { [jid: string]: ChatUpdate }\n    chatDeletes: Set<string>\n    contactUpserts: { [jid: string]: Contact }\n    contactUpdates: { [jid: string]: Partial<Contact> }\n    messageUpserts: { [key: string]: { type: MessageUpsertType, message: WAMessage } }\n    messageUpdates: { [key: string]: WAMessageUpdate }\n    messageDeletes: { [key: string]: WAMessageKey }\n    messageReactions: { [key: string]: { key: WAMessageKey, reactions: proto.IReaction[] } }\n    messageReceipts: { [key: string]: { key: WAMessageKey, userReceipt: proto.IUserReceipt[] } }\n    groupUpdates: { [jid: string]: Partial<GroupMetadata> }\n}\n\nexport type BaileysEvent = keyof BaileysEventMap\n\nexport interface BaileysEventEmitter {\n\ton<T extends keyof BaileysEventMap>(event: T, listener: (arg: BaileysEventMap[T]) => void): void\n    off<T extends keyof BaileysEventMap>(event: T, listener: (arg: BaileysEventMap[T]) => void): void\n    removeAllListeners<T extends keyof BaileysEventMap>(event: T): void\n\temit<T extends keyof BaileysEventMap>(event: T, arg: BaileysEventMap[T]): boolean\n}"]}