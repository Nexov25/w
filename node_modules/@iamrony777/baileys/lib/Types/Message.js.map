{"version":3,"file":"Message.js","sourceRoot":"/","sources":["Types/Message.ts"],"names":[],"mappings":";;;AAIA,2CAAqC;AAMnB,wFANT,eAAK,OAMW;AAUzB,6EAA6E;AAC/D,QAAA,iBAAiB,GAAG,eAAK,CAAC,cAAc,CAAC,QAAQ,CAAA;AAC/D,6EAA6E;AAC/D,QAAA,eAAe,GAAG,eAAK,CAAC,cAAc,CAAC,MAAM,CAAA","sourcesContent":["import { AxiosRequestConfig } from 'axios'\nimport type { Logger } from 'pino'\nimport type { Readable } from 'stream'\nimport type { URL } from 'url'\nimport { proto } from '../../WAProto'\nimport { MEDIA_HKDF_KEY_MAPPING } from '../Defaults'\nimport type { GroupMetadata } from './GroupMetadata'\nimport { CacheStore } from './Socket'\n\n// export the WAMessage Prototypes\nexport { proto as WAProto }\nexport type WAMessage = proto.IWebMessageInfo\nexport type WAMessageContent = proto.IMessage\nexport type WAContactMessage = proto.Message.IContactMessage\nexport type WAContactsArrayMessage = proto.Message.IContactsArrayMessage\nexport type WAMessageKey = proto.IMessageKey\nexport type WATextMessage = proto.Message.IExtendedTextMessage\nexport type WAContextInfo = proto.IContextInfo\nexport type WALocationMessage = proto.Message.ILocationMessage\nexport type WAGenericMediaMessage = proto.Message.IVideoMessage | proto.Message.IImageMessage | proto.Message.IAudioMessage | proto.Message.IDocumentMessage | proto.Message.IStickerMessage\n// eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars\nexport import WAMessageStubType = proto.WebMessageInfo.StubType\n// eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars\nexport import WAMessageStatus = proto.WebMessageInfo.Status\nexport type WAMediaUpload = Buffer | { url: URL | string } | { stream: Readable }\n/** Set of message types that are supported by the library */\nexport type MessageType = keyof proto.Message\n\nexport type DownloadableMessage = { mediaKey?: Uint8Array | null, directPath?: string | null, url?: string | null }\n\nexport type MessageReceiptType = 'read' | 'read-self' | 'hist_sync' | 'peer_msg' | 'sender' | 'inactive' | 'played' | undefined\n\nexport type MediaConnInfo = {\n    auth: string\n    ttl: number\n    hosts: { hostname: string, maxContentLengthBytes: number }[]\n    fetchDate: Date\n}\n\nexport interface WAUrlInfo {\n    'canonical-url': string\n    'matched-text': string\n    title: string\n    description?: string\n    jpegThumbnail?: Buffer\n    highQualityThumbnail?: proto.Message.IImageMessage\n    originalThumbnailUrl?: string\n}\n\n// types to generate WA messages\ntype Mentionable = {\n    /** list of jids that are mentioned in the accompanying text */\n    mentions?: string[]\n}\ntype Contextable = {\n    /** add contextInfo to the message */\n    contextInfo?: proto.IContextInfo\n}\ntype ViewOnce = {\n    viewOnce?: boolean\n}\n\ntype Buttonable = {\n    /** add buttons to the message  */\n    buttons?: proto.Message.ButtonsMessage.IButton[]\n}\ntype Templatable = {\n    /** add buttons to the message (conflicts with normal buttons)*/\n    templateButtons?: proto.IHydratedTemplateButton[]\n\n    footer?: string\n}\ntype Editable = {\n  edit?: WAMessageKey\n}\ntype Listable = {\n    /** Sections of the List */\n    sections?: proto.Message.ListMessage.ISection[]\n\n    /** Title of a List Message only */\n    title?: string\n\n    /** Text of the bnutton on the list (required) */\n    buttonText?: string\n}\ntype WithDimensions = {\n    width?: number\n    height?: number\n}\n\nexport type PollMessageOptions = {\n    name: string\n    selectableCount?: number\n    values: string[]\n    /** 32 byte message secret to encrypt poll selections */\n    messageSecret?: Uint8Array\n}\n\ntype SharePhoneNumber = {\n    sharePhoneNumber: boolean\n}\n\ntype RequestPhoneNumber = {\n    requestPhoneNumber: boolean\n}\n\nexport type MediaType = keyof typeof MEDIA_HKDF_KEY_MAPPING\nexport type AnyMediaMessageContent = (\n    ({\n        image: WAMediaUpload\n        caption?: string\n        jpegThumbnail?: string\n    } & Mentionable & Contextable & Buttonable & Templatable & WithDimensions)\n    | ({\n        video: WAMediaUpload\n        caption?: string\n        gifPlayback?: boolean\n        jpegThumbnail?: string\n    } & Mentionable & Contextable & Buttonable & Templatable & WithDimensions)\n    | {\n        audio: WAMediaUpload\n        /** if set to true, will send as a `voice note` */\n        ptt?: boolean\n        /** optionally tell the duration of the audio */\n        seconds?: number\n    }\n    | ({\n        sticker: WAMediaUpload\n        isAnimated?: boolean\n    } & WithDimensions) | ({\n        document: WAMediaUpload\n        mimetype: string\n        fileName?: string\n        caption?: string\n    } & Contextable & Buttonable & Templatable))\n    & { mimetype?: string } & Editable\n\nexport type ButtonReplyInfo = {\n    displayText: string\n    id: string\n    index: number\n}\n\nexport type WASendableProduct = Omit<proto.Message.ProductMessage.IProductSnapshot, 'productImage'> & {\n    productImage: WAMediaUpload\n}\n\nexport type AnyRegularMessageContent = (\n    ({\n\t    text: string\n        linkPreview?: WAUrlInfo | null\n    }\n    & Mentionable & Contextable & Buttonable & Templatable & Listable & Editable)\n    | AnyMediaMessageContent\n    | ({\n        poll: PollMessageOptions\n    } & Mentionable & Contextable & Buttonable & Templatable & Editable)\n    | {\n        contacts: {\n            displayName?: string\n            contacts: proto.Message.IContactMessage[]\n        }\n    }\n    | {\n        location: WALocationMessage\n    }\n    | { react: proto.Message.IReactionMessage }\n    | { pinMessage: {\n        pinInChatMessage: proto.Message.IPinInChatMessage\n        duration: number\n    } }\n    | {\n        buttonReply: ButtonReplyInfo\n        type: 'template' | 'plain'\n    }\n    | {\n        listReply: Omit<proto.Message.IListResponseMessage, 'contextInfo'>\n    }\n    | {\n        product: WASendableProduct\n        businessOwnerJid?: string\n        body?: string\n        footer?: string\n    } | SharePhoneNumber | RequestPhoneNumber\n) & ViewOnce\n\nexport type AnyMessageContent = AnyRegularMessageContent | {\n\tforward: WAMessage\n\tforce?: boolean\n} | {\n    /** Delete your message or anyone's message in a group (admin required) */\n\tdelete: WAMessageKey\n} | {\n\tdisappearingMessagesInChat: boolean | number\n}\n\nexport type GroupMetadataParticipants = Pick<GroupMetadata, 'participants'>\n\ntype MinimalRelayOptions = {\n    /** override the message ID with a custom provided string */\n    messageId?: string\n    /** cached group metadata, use to prevent redundant requests to WA & speed up msg sending */\n    cachedGroupMetadata?: (jid: string) => Promise<GroupMetadataParticipants | undefined>\n}\n\nexport type MessageRelayOptions = MinimalRelayOptions & {\n    /** only send to a specific participant; used when a message decryption fails for a single user */\n    participant?: { jid: string, count: number }\n    /** additional attributes to add to the WA binary node */\n    additionalAttributes?: { [_: string]: string }\n    /** should we use the devices cache, or fetch afresh from the server; default assumed to be \"true\" */\n    useUserDevicesCache?: boolean\n    /** jid list of participants for status@broadcast */\n    statusJidList?: string[]\n}\n\nexport type MiscMessageGenerationOptions = MinimalRelayOptions & {\n    /** optional, if you want to manually set the timestamp of the message */\n\ttimestamp?: Date\n    /** the message you want to quote */\n\tquoted?: WAMessage\n    /** disappearing messages settings */\n    ephemeralExpiration?: number | string\n    /** timeout for media upload to WA server */\n    mediaUploadTimeoutMs?: number\n    /** jid list of participants for status@broadcast */\n    statusJidList?: string[]\n    /** backgroundcolor for status */\n    backgroundColor?: string\n    /** font type for status */\n    font?: number\n}\nexport type MessageGenerationOptionsFromContent = MiscMessageGenerationOptions & {\n\tuserJid: string\n}\n\nexport type WAMediaUploadFunction = (readStream: Readable, opts: { fileEncSha256B64: string, mediaType: MediaType, timeoutMs?: number }) => Promise<{ mediaUrl: string, directPath: string }>\n\nexport type MediaGenerationOptions = {\n\tlogger?: Logger\n    mediaTypeOverride?: MediaType\n    upload: WAMediaUploadFunction\n    /** cache media so it does not have to be uploaded again */\n    mediaCache?: CacheStore\n\n    mediaUploadTimeoutMs?: number\n\n    options?: AxiosRequestConfig\n\n    backgroundColor?: string\n\n    font?: number\n}\nexport type MessageContentGenerationOptions = MediaGenerationOptions & {\n\tgetUrlInfo?: (text: string) => Promise<WAUrlInfo | undefined>\n}\nexport type MessageGenerationOptions = MessageContentGenerationOptions & MessageGenerationOptionsFromContent\n\n/**\n * Type of message upsert\n * 1. notify => notify the user, this message was just received\n * 2. append => append the message to the chat history, no notification required\n */\nexport type MessageUpsertType = 'append' | 'notify'\n\nexport type MessageUserReceipt = proto.IUserReceipt\n\nexport type WAMessageUpdate = { update: Partial<WAMessage>, key: proto.IMessageKey }\n\nexport type WAMessageCursor = { before: WAMessageKey | undefined } | { after: WAMessageKey | undefined }\n\nexport type MessageUserReceiptUpdate = { key: proto.IMessageKey, receipt: MessageUserReceipt }\n\nexport type MediaDecryptionKeyInfo = {\n    iv: Buffer\n    cipherKey: Buffer\n    macKey?: Buffer\n}\n\nexport type MinimalMessage = Pick<proto.IWebMessageInfo, 'key' | 'messageTimestamp'>"]}