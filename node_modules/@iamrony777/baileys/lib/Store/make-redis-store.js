"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waLabelAssociationKey = exports.waMessageID = exports.waChatKey = void 0;
const WAProto_1 = require("../../WAProto");
const Defaults_1 = require("../Defaults");
const LabelAssociation_1 = require("../Types/LabelAssociation");
const Utils_1 = require("../Utils");
const WABinary_1 = require("../WABinary");
const make_ordered_dictionary_1 = __importDefault(require("./make-ordered-dictionary"));
const object_repository_1 = require("./object-repository");
const waChatKey = (pin) => ({
    key: (c) => (pin ? (c.pinned ? '1' : '0') : '') +
        (c.archived ? '0' : '1') +
        (c.conversationTimestamp
            ? c.conversationTimestamp.toString(16).padStart(8, '0')
            : '') +
        c.id,
    compare: (k1, k2) => k2.localeCompare(k1),
});
exports.waChatKey = waChatKey;
const waMessageID = (m) => m.key.id || '';
exports.waMessageID = waMessageID;
exports.waLabelAssociationKey = {
    key: (la) => la.type === LabelAssociation_1.LabelAssociationType.Chat
        ? la.chatId + la.labelId
        : la.chatId + la.messageId + la.labelId,
    compare: (k1, k2) => k2.localeCompare(k1),
};
const makeMessagesDictionary = () => (0, make_ordered_dictionary_1.default)(exports.waMessageID);
const predefinedLabels = Object.freeze({
    '0': {
        id: '0',
        name: 'New customer',
        predefinedId: '0',
        color: 0,
        deleted: false,
    },
    '1': {
        id: '1',
        name: 'New order',
        predefinedId: '1',
        color: 1,
        deleted: false,
    },
    '2': {
        id: '2',
        name: 'Pending payment',
        predefinedId: '2',
        color: 2,
        deleted: false,
    },
    '3': {
        id: '3',
        name: 'Paid',
        predefinedId: '3',
        color: 3,
        deleted: false,
    },
    '4': {
        id: '4',
        name: 'Order completed',
        predefinedId: '4',
        color: 4,
        deleted: false,
    },
});
exports.default = ({ logger: _logger, chatKey, labelAssociationKey, redis, suffix, }) => {
    chatKey = chatKey || (0, exports.waChatKey)(true);
    labelAssociationKey = labelAssociationKey || exports.waLabelAssociationKey;
    suffix = suffix || 'store';
    const logger = _logger || Defaults_1.DEFAULT_CONNECTION_CONFIG.logger.child({ stream: 'redis:store' });
    const KeyedDB = require('@adiwajshing/keyed-db').default;
    const chats = new KeyedDB(chatKey, (c) => c.id);
    const messages = {};
    const contacts = {};
    const groupMetadata = {};
    const presences = {};
    const state = { connection: 'close' };
    const labels = new object_repository_1.ObjectRepository(predefinedLabels);
    const labelAssociations = new KeyedDB(labelAssociationKey, labelAssociationKey.key);
    const assertMessageList = (jid) => {
        if (!messages[jid]) {
            messages[jid] = makeMessagesDictionary();
        }
        return messages[jid];
    };
    const contactsUpsert = (newContacts) => {
        const oldContacts = new Set(Object.keys(contacts));
        for (const contact of newContacts) {
            oldContacts.delete(contact.id);
            contacts[contact.id] = Object.assign(contacts[contact.id] || {}, contact);
        }
        return oldContacts;
    };
    const labelsUpsert = (newLabels) => {
        for (const label of newLabels) {
            labels.upsertById(label.id, label);
        }
    };
    /**
     * binds to a BaileysEventEmitter.
     * It listens to all events and constructs a state that you can query accurate data from.
     * Eg. can use the store to fetch chats, contacts, messages etc.
     * @param ev typically the event emitter from the socket connection
     */
    const bind = (ev) => {
        ev.on('connection.update', (update) => {
            Object.assign(state, update);
        });
        ev.on('messaging-history.set', ({ chats: newChats, contacts: newContacts, messages: newMessages, isLatest, }) => {
            if (isLatest) {
                chats.clear();
                for (const id in messages) {
                    delete messages[id];
                }
            }
            const chatsAdded = chats.insertIfAbsent(...newChats).length;
            logger.debug({ chatsAdded }, 'synced chats');
            const oldContacts = contactsUpsert(newContacts);
            if (isLatest) {
                for (const jid of oldContacts) {
                    delete contacts[jid];
                }
            }
            logger.debug({ deletedContacts: isLatest ? oldContacts.size : 0, newContacts }, 'synced contacts');
            for (const msg of newMessages) {
                const jid = msg.key.remoteJid;
                const list = assertMessageList(jid);
                list.upsert(msg, 'prepend');
            }
            logger.debug({ messages: newMessages.length }, 'synced messages');
        });
        ev.on('contacts.upsert', (contacts) => {
            contactsUpsert(contacts);
        });
        ev.on('contacts.update', (updates) => {
            for (const update of updates) {
                if (contacts[update.id]) {
                    Object.assign(contacts[update.id], update);
                }
                else {
                    logger.debug({ update }, 'got update for non-existant contact');
                }
            }
        });
        ev.on('chats.upsert', (newChats) => {
            chats.upsert(...newChats);
        });
        ev.on('chats.update', (updates) => {
            for (let update of updates) {
                const result = chats.update(update.id, (chat) => {
                    if (update.unreadCount > 0) {
                        update = Object.assign({}, update);
                        update.unreadCount = (chat.unreadCount || 0) + update.unreadCount;
                    }
                    Object.assign(chat, update);
                });
                if (!result) {
                    logger.debug({ update }, 'got update for non-existant chat');
                }
            }
        });
        ev.on('labels.edit', (label) => {
            if (label.deleted) {
                return labels.deleteById(label.id);
            }
            // WhatsApp can store only up to 20 labels
            if (labels.count() < 20) {
                return labels.upsertById(label.id, label);
            }
            logger.error('Labels count exceed');
        });
        ev.on('labels.association', ({ type, association }) => {
            switch (type) {
                case 'add':
                    labelAssociations.upsert(association);
                    break;
                case 'remove':
                    labelAssociations.delete(association);
                    break;
                default:
                    logger.error(`unknown operation type [${type}]`);
            }
        });
        ev.on('presence.update', ({ id, presences: update }) => {
            presences[id] = presences[id] || {};
            Object.assign(presences[id], update);
        });
        ev.on('chats.delete', (deletions) => {
            for (const item of deletions) {
                if (chats.get(item)) {
                    chats.deleteById(item);
                }
            }
        });
        ev.on('messages.upsert', ({ messages: newMessages, type }) => {
            switch (type) {
                case 'append':
                case 'notify':
                    for (const msg of newMessages) {
                        const jid = (0, WABinary_1.jidNormalizedUser)(msg.key.remoteJid);
                        const list = assertMessageList(jid);
                        list.upsert(msg, 'append');
                        if (type === 'notify') {
                            if (!chats.get(jid)) {
                                ev.emit('chats.upsert', [
                                    {
                                        id: jid,
                                        conversationTimestamp: (0, Utils_1.toNumber)(msg.messageTimestamp),
                                        unreadCount: 1,
                                    },
                                ]);
                            }
                        }
                    }
                    break;
            }
        });
        ev.on('messages.update', (updates) => {
            var _a;
            for (const { update, key } of updates) {
                const list = assertMessageList((0, WABinary_1.jidNormalizedUser)(key.remoteJid));
                if (update === null || update === void 0 ? void 0 : update.status) {
                    const listStatus = (_a = list.get(key.id)) === null || _a === void 0 ? void 0 : _a.status;
                    if (listStatus && (update === null || update === void 0 ? void 0 : update.status) <= listStatus) {
                        logger.debug({ update, storedStatus: listStatus }, 'status stored newer then update');
                        delete update.status;
                        logger.debug({ update }, 'new update object');
                    }
                }
                const result = list.updateAssign(key.id, update);
                if (!result) {
                    logger.debug({ update }, 'got update for non-existent message');
                }
            }
        });
        ev.on('messages.delete', (item) => {
            if ('all' in item) {
                const list = messages[item.jid];
                list === null || list === void 0 ? void 0 : list.clear();
            }
            else {
                const jid = item.keys[0].remoteJid;
                const list = messages[jid];
                if (list) {
                    const idSet = new Set(item.keys.map((k) => k.id));
                    list.filter((m) => !idSet.has(m.key.id));
                }
            }
        });
        ev.on('groups.update', (updates) => {
            for (const update of updates) {
                const id = update.id;
                if (groupMetadata[id]) {
                    Object.assign(groupMetadata[id], update);
                }
                else {
                    logger.debug({ update }, 'got update for non-existant group metadata');
                }
            }
        });
        ev.on('group-participants.update', ({ id, participants, action }) => {
            const metadata = groupMetadata[id];
            if (metadata) {
                switch (action) {
                    case 'add':
                        metadata.participants.push(...participants.map((id) => ({
                            id,
                            isAdmin: false,
                            isSuperAdmin: false,
                        })));
                        break;
                    case 'demote':
                    case 'promote':
                        for (const participant of metadata.participants) {
                            if (participants.includes(participant.id)) {
                                participant.isAdmin = action === 'promote';
                            }
                        }
                        break;
                    case 'remove':
                        metadata.participants = metadata.participants.filter((p) => !participants.includes(p.id));
                        break;
                }
            }
        });
        ev.on('message-receipt.update', (updates) => {
            for (const { key, receipt } of updates) {
                const obj = messages[key.remoteJid];
                const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);
                if (msg) {
                    (0, Utils_1.updateMessageWithReceipt)(msg, receipt);
                }
            }
        });
        ev.on('messages.reaction', (reactions) => {
            for (const { key, reaction } of reactions) {
                const obj = messages[key.remoteJid];
                const msg = obj === null || obj === void 0 ? void 0 : obj.get(key.id);
                if (msg) {
                    (0, Utils_1.updateMessageWithReaction)(msg, reaction);
                }
            }
        });
    };
    const toJSON = () => ({
        chats,
        contacts,
        messages,
        labels,
        labelAssociations,
    });
    const fromJSON = (json) => {
        chats.upsert(...json.chats);
        labelAssociations.upsert(...(json.labelAssociations || []));
        contactsUpsert(Object.values(json.contacts));
        labelsUpsert(Object.values(json.labels || {}));
        for (const jid in json.messages) {
            const list = assertMessageList(jid);
            for (const msg of json.messages[jid]) {
                list.upsert(WAProto_1.proto.WebMessageInfo.fromObject(msg), 'append');
            }
        }
    };
    return {
        chats,
        contacts,
        messages,
        groupMetadata,
        state,
        presences,
        labels,
        labelAssociations,
        bind,
        /** loads messages from the store, if not found -- uses the legacy connection */
        loadMessages: (jid, count, cursor) => __awaiter(void 0, void 0, void 0, function* () {
            const list = assertMessageList(jid);
            const mode = !cursor || 'before' in cursor ? 'before' : 'after';
            const cursorKey = !!cursor
                ? 'before' in cursor
                    ? cursor.before
                    : cursor.after
                : undefined;
            const cursorValue = cursorKey ? list.get(cursorKey.id) : undefined;
            let messages;
            if (list && mode === 'before' && (!cursorKey || cursorValue)) {
                if (cursorValue) {
                    const msgIdx = list.array.findIndex((m) => m.key.id === (cursorKey === null || cursorKey === void 0 ? void 0 : cursorKey.id));
                    messages = list.array.slice(0, msgIdx);
                }
                else {
                    messages = list.array;
                }
                const diff = count - messages.length;
                if (diff < 0) {
                    messages = messages.slice(-count); // get the last X messages
                }
            }
            else {
                messages = [];
            }
            return messages;
        }),
        /**
         * Get all available labels for profile
         *
         * Keep in mind that the list is formed from predefined tags and tags
         * that were "caught" during their editing.
         */
        getLabels: () => {
            return labels;
        },
        /**
         * Get labels for chat
         *
         * @returns Label IDs
         **/
        getChatLabels: (chatId) => {
            return labelAssociations.filter((la) => la.chatId === chatId).all();
        },
        getContactInfo: (chatId) => __awaiter(void 0, void 0, void 0, function* () {
            const contacts = yield redis.hGet(`contacts:${suffix}`, chatId);
            return contacts
                ? JSON.parse(contacts, Utils_1.BufferJSON.reviver)
                : null;
        }),
        /**
         * Get labels for message
         *
         * @returns Label IDs
         **/
        getMessageLabels: (messageId) => {
            const associations = labelAssociations
                .filter((la) => la.messageId === messageId)
                .all();
            return associations.map(({ labelId }) => labelId);
        },
        loadMessage: (jid, id) => __awaiter(void 0, void 0, void 0, function* () { var _a; return (_a = messages[jid]) === null || _a === void 0 ? void 0 : _a.get(id); }),
        mostRecentMessage: (jid) => __awaiter(void 0, void 0, void 0, function* () {
            var _b;
            const message = (_b = messages[jid]) === null || _b === void 0 ? void 0 : _b.array.slice(-1)[0];
            return message;
        }),
        fetchImageUrl: (jid, sock) => __awaiter(void 0, void 0, void 0, function* () {
            const contact = contacts[jid];
            if (!contact) {
                return sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid);
            }
            if (typeof contact.imgUrl === 'undefined') {
                contact.imgUrl = yield (sock === null || sock === void 0 ? void 0 : sock.profilePictureUrl(jid));
            }
            return contact.imgUrl;
        }),
        fetchGroupMetadata: (jid, sock) => __awaiter(void 0, void 0, void 0, function* () {
            if (!groupMetadata[jid]) {
                const metadata = yield (sock === null || sock === void 0 ? void 0 : sock.groupMetadata(jid));
                if (metadata) {
                    groupMetadata[jid] = metadata;
                }
            }
            return groupMetadata[jid];
        }),
        // fetchBroadcastListInfo: async(jid: string, sock: WASocket | undefined) => {
        // 	if(!groupMetadata[jid]) {
        // 		const metadata = await sock?.getBroadcastListInfo(jid)
        // 		if(metadata) {
        // 			groupMetadata[jid] = metadata
        // 		}
        // 	}
        // 	return groupMetadata[jid]
        // },
        fetchMessageReceipts: ({ remoteJid, id }) => __awaiter(void 0, void 0, void 0, function* () {
            const list = messages[remoteJid];
            const msg = list === null || list === void 0 ? void 0 : list.get(id);
            return msg === null || msg === void 0 ? void 0 : msg.userReceipt;
        }),
        toJSON,
        fromJSON,
        uploadToDb: () => __awaiter(void 0, void 0, void 0, function* () {
            if (!redis.isReady) {
                yield redis.connect();
            }
            const jsonData = toJSON();
            for (const key of Object.keys(jsonData)) {
                const data = jsonData[key];
                const suffixKey = `${key}:${suffix}`;
                switch (key) {
                    case 'chats':
                        // @ts-ignore
                        for (const chat of data.array) {
                            yield redis.hSet(suffixKey, chat.id, JSON.stringify(chat, Utils_1.BufferJSON.replacer));
                        }
                        break;
                    case 'contacts':
                        for (const contact of Object.values(data)) {
                            yield redis.hSet(suffixKey, contact.id, JSON.stringify(contact, Utils_1.BufferJSON.replacer));
                        }
                        break;
                    case 'messages':
                        for (const msgKey of Object.keys(data)) {
                            yield redis.hSet(suffixKey, msgKey, JSON.stringify(data[msgKey], Utils_1.BufferJSON.replacer));
                        }
                        break;
                    case 'labelAssociations':
                    case 'labels':
                        yield redis.set(suffixKey, JSON.stringify(data, Utils_1.BufferJSON.replacer));
                        break;
                }
            }
        }),
        readFromDb: () => __awaiter(void 0, void 0, void 0, function* () {
            if (!redis.isReady) {
                yield redis.connect();
            }
            const jsonObject = {
                chats: [],
                contacts: {},
                messages: {},
                labels: {},
                labelAssociations: []
            };
            const readObjectFromDb = (key) => __awaiter(void 0, void 0, void 0, function* () {
                const tempObj = yield redis.hGetAll(`${key}:${suffix}`);
                const parsedObj = Object.keys(tempObj).map((id) => JSON.parse(tempObj[id], Utils_1.BufferJSON.reviver));
                jsonObject[key] = parsedObj;
            });
            const readArrayFromDb = (key) => __awaiter(void 0, void 0, void 0, function* () {
                const parsedArray = JSON.parse((yield redis.get(`${key}:${suffix}`)) || '[]', Utils_1.BufferJSON.reviver);
                jsonObject[key] = parsedArray;
            });
            yield Promise.all([
                readObjectFromDb('chats'),
                readObjectFromDb('contacts'),
                readObjectFromDb('messages'),
                readArrayFromDb('labels'),
                readArrayFromDb('labelAssociations'),
            ]);
            fromJSON(jsonObject);
        }),
    };
};
//# sourceMappingURL=make-redis-store.js.map