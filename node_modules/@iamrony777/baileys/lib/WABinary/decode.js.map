{"version":3,"file":"decode.js","sourceRoot":"/","sources":["WABinary/decode.ts"],"names":[],"mappings":"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","sourcesContent":["import { inflateSync } from 'zlib'\nimport * as constants from './constants'\nimport { jidEncode } from './jid-utils'\nimport type { BinaryNode, BinaryNodeCodingOptions } from './types'\n\nexport const decompressingIfRequired = (buffer: Buffer) => {\n\tif(2 & buffer.readUInt8()) {\n\t\tbuffer = inflateSync(buffer.slice(1))\n\t} else { // nodes with no compression have a 0x00 prefix, we remove that\n\t\tbuffer = buffer.slice(1)\n\t}\n\n\treturn buffer\n}\n\nexport const decodeDecompressedBinaryNode = (\n\tbuffer: Buffer,\n\topts: Pick<BinaryNodeCodingOptions, 'DOUBLE_BYTE_TOKENS' | 'SINGLE_BYTE_TOKENS' | 'TAGS'>,\n\tindexRef: { index: number } = { index: 0 }\n): BinaryNode => {\n\tconst { DOUBLE_BYTE_TOKENS, SINGLE_BYTE_TOKENS, TAGS } = opts\n\n\tconst checkEOS = (length: number) => {\n\t\tif(indexRef.index + length > buffer.length) {\n\t\t\tthrow new Error('end of stream')\n\t\t}\n\t}\n\n\tconst next = () => {\n\t\tconst value = buffer[indexRef.index]\n\t\tindexRef.index += 1\n\t\treturn value\n\t}\n\n\tconst readByte = () => {\n\t\tcheckEOS(1)\n\t\treturn next()\n\t}\n\n\tconst readBytes = (n: number) => {\n\t\tcheckEOS(n)\n\t\tconst value = buffer.slice(indexRef.index, indexRef.index + n)\n\t\tindexRef.index += n\n\t\treturn value\n\t}\n\n\tconst readStringFromChars = (length: number) => {\n\t\treturn readBytes(length).toString('utf-8')\n\t}\n\n\tconst readInt = (n: number, littleEndian = false) => {\n\t\tcheckEOS(n)\n\t\tlet val = 0\n\t\tfor(let i = 0; i < n; i++) {\n\t\t\tconst shift = littleEndian ? i : n - 1 - i\n\t\t\tval |= next() << (shift * 8)\n\t\t}\n\n\t\treturn val\n\t}\n\n\tconst readInt20 = () => {\n\t\tcheckEOS(3)\n\t\treturn ((next() & 15) << 16) + (next() << 8) + next()\n\t}\n\n\tconst unpackHex = (value: number) => {\n\t\tif(value >= 0 && value < 16) {\n\t\t\treturn value < 10 ? '0'.charCodeAt(0) + value : 'A'.charCodeAt(0) + value - 10\n\t\t}\n\n\t\tthrow new Error('invalid hex: ' + value)\n\t}\n\n\tconst unpackNibble = (value: number) => {\n\t\tif(value >= 0 && value <= 9) {\n\t\t\treturn '0'.charCodeAt(0) + value\n\t\t}\n\n\t\tswitch (value) {\n\t\tcase 10:\n\t\t\treturn '-'.charCodeAt(0)\n\t\tcase 11:\n\t\t\treturn '.'.charCodeAt(0)\n\t\tcase 15:\n\t\t\treturn '\\0'.charCodeAt(0)\n\t\tdefault:\n\t\t\tthrow new Error('invalid nibble: ' + value)\n\t\t}\n\t}\n\n\tconst unpackByte = (tag: number, value: number) => {\n\t\tif(tag === TAGS.NIBBLE_8) {\n\t\t\treturn unpackNibble(value)\n\t\t} else if(tag === TAGS.HEX_8) {\n\t\t\treturn unpackHex(value)\n\t\t} else {\n\t\t\tthrow new Error('unknown tag: ' + tag)\n\t\t}\n\t}\n\n\tconst readPacked8 = (tag: number) => {\n\t\tconst startByte = readByte()\n\t\tlet value = ''\n\n\t\tfor(let i = 0; i < (startByte & 127); i++) {\n\t\t\tconst curByte = readByte()\n\t\t\tvalue += String.fromCharCode(unpackByte(tag, (curByte & 0xf0) >> 4))\n\t\t\tvalue += String.fromCharCode(unpackByte(tag, curByte & 0x0f))\n\t\t}\n\n\t\tif(startByte >> 7 !== 0) {\n\t\t\tvalue = value.slice(0, -1)\n\t\t}\n\n\t\treturn value\n\t}\n\n\tconst isListTag = (tag: number) => {\n\t\treturn tag === TAGS.LIST_EMPTY || tag === TAGS.LIST_8 || tag === TAGS.LIST_16\n\t}\n\n\tconst readListSize = (tag: number) => {\n\t\tswitch (tag) {\n\t\tcase TAGS.LIST_EMPTY:\n\t\t\treturn 0\n\t\tcase TAGS.LIST_8:\n\t\t\treturn readByte()\n\t\tcase TAGS.LIST_16:\n\t\t\treturn readInt(2)\n\t\tdefault:\n\t\t\tthrow new Error('invalid tag for list size: ' + tag)\n\t\t}\n\t}\n\n\tconst readJidPair = () => {\n\t\tconst i = readString(readByte())\n\t\tconst j = readString(readByte())\n\t\tif(j) {\n\t\t\treturn (i || '') + '@' + j\n\t\t}\n\n\t\tthrow new Error('invalid jid pair: ' + i + ', ' + j)\n\t}\n\n\tconst readAdJid = () => {\n\t\tconst agent = readByte()\n\t\tconst device = readByte()\n\t\tconst user = readString(readByte())\n\n\t\treturn jidEncode(user, agent === 0 ? 's.whatsapp.net' : 'lid', device)\n\t}\n\n\tconst readString = (tag: number): string => {\n\t\tif(tag >= 1 && tag < SINGLE_BYTE_TOKENS.length) {\n\t\t\treturn SINGLE_BYTE_TOKENS[tag] || ''\n\t\t}\n\n\t\tswitch (tag) {\n\t\tcase TAGS.DICTIONARY_0:\n\t\tcase TAGS.DICTIONARY_1:\n\t\tcase TAGS.DICTIONARY_2:\n\t\tcase TAGS.DICTIONARY_3:\n\t\t\treturn getTokenDouble(tag - TAGS.DICTIONARY_0, readByte())\n\t\tcase TAGS.LIST_EMPTY:\n\t\t\treturn ''\n\t\tcase TAGS.BINARY_8:\n\t\t\treturn readStringFromChars(readByte())\n\t\tcase TAGS.BINARY_20:\n\t\t\treturn readStringFromChars(readInt20())\n\t\tcase TAGS.BINARY_32:\n\t\t\treturn readStringFromChars(readInt(4))\n\t\tcase TAGS.JID_PAIR:\n\t\t\treturn readJidPair()\n\t\tcase TAGS.AD_JID:\n\t\t\treturn readAdJid()\n\t\tcase TAGS.HEX_8:\n\t\tcase TAGS.NIBBLE_8:\n\t\t\treturn readPacked8(tag)\n\t\tdefault:\n\t\t\tthrow new Error('invalid string with tag: ' + tag)\n\t\t}\n\t}\n\n\tconst readList = (tag: number) => {\n\t\tconst items: BinaryNode[] = []\n\t\tconst size = readListSize(tag)\n\t\tfor(let i = 0;i < size;i++) {\n\t\t\titems.push(decodeDecompressedBinaryNode(buffer, opts, indexRef))\n\t\t}\n\n\t\treturn items\n\t}\n\n\tconst getTokenDouble = (index1: number, index2: number) => {\n\t\tconst dict = DOUBLE_BYTE_TOKENS[index1]\n\t\tif(!dict) {\n\t\t\tthrow new Error(`Invalid double token dict (${index1})`)\n\t\t}\n\n\t\tconst value = dict[index2]\n\t\tif(typeof value === 'undefined') {\n\t\t\tthrow new Error(`Invalid double token (${index2})`)\n\t\t}\n\n\t\treturn value\n\t}\n\n\tconst listSize = readListSize(readByte())\n\tconst header = readString(readByte())\n\tif(!listSize || !header.length) {\n\t\tthrow new Error('invalid node')\n\t}\n\n\tconst attrs: BinaryNode['attrs'] = { }\n\tlet data: BinaryNode['content']\n\tif(listSize === 0 || !header) {\n\t\tthrow new Error('invalid node')\n\t}\n\n\t// read the attributes in\n\tconst attributesLength = (listSize - 1) >> 1\n\tfor(let i = 0; i < attributesLength; i++) {\n\t\tconst key = readString(readByte())\n\t\tconst value = readString(readByte())\n\n\t\tattrs[key] = value\n\t}\n\n\tif(listSize % 2 === 0) {\n\t\tconst tag = readByte()\n\t\tif(isListTag(tag)) {\n\t\t\tdata = readList(tag)\n\t\t} else {\n\t\t\tlet decoded: Buffer | string\n\t\t\tswitch (tag) {\n\t\t\tcase TAGS.BINARY_8:\n\t\t\t\tdecoded = readBytes(readByte())\n\t\t\t\tbreak\n\t\t\tcase TAGS.BINARY_20:\n\t\t\t\tdecoded = readBytes(readInt20())\n\t\t\t\tbreak\n\t\t\tcase TAGS.BINARY_32:\n\t\t\t\tdecoded = readBytes(readInt(4))\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tdecoded = readString(tag)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdata = decoded\n\t\t}\n\t}\n\n\treturn {\n\t\ttag: header,\n\t\tattrs,\n\t\tcontent: data\n\t}\n}\n\nexport const decodeBinaryNode = (buff: Buffer): BinaryNode => {\n\tconst decompBuff = decompressingIfRequired(buff)\n\treturn decodeDecompressedBinaryNode(decompBuff, constants)\n}\n"]}